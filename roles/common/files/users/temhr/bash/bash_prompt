#!/usr/bin/env bash
# Exit early if not in an interactive shell
[[ $- != *i* ]] && return

# Get the directory of the current script
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Read emojis from a single-line, whitespace-separated file
if [[ -f "${SCRIPT_DIR}/emoticons" ]]; then
    # Use mapfile to handle the large emoji list more reliably
    mapfile -t EMOJIS < <(tr ' ' '\n' < "${SCRIPT_DIR}/emoticons" | grep -v '^

# Function to select a random emoji
RANDOM_EMOJI() {
    # Check if array has elements to prevent division by zero
    if [[ ${#EMOJIS[@]} -gt 0 ]]; then
        echo "${EMOJIS[RANDOM % ${#EMOJIS[@]}]}"
    else
        # Fallback if somehow still empty
        echo "ü§ñ"
    fi
}

# ANSI 256 color escapes (properly wrapped in \[ \] for prompt alignment)
BRACKET_COLOR="\[\033[38;5;35m\]"
CLOCK_COLOR="\[\033[38;5;35m\]"
JOB_COLOR="\[\033[38;5;33m\]"
PATH_COLOR="\[\033[38;5;33m\]"
LINE_COLOR="\[\033[38;5;248m\]"
RESET_COLOR="\[\033[0m\]"

# Line characters (UTF-8)
LINE_BOTTOM="‚îÄ"
LINE_BOTTOM_CORNER="‚îî"
LINE_UPPER_CORNER="‚îå"
LINE_STRAIGHT="‚îÄ"

# Misc symbols
END_CHARACTER="|"
WHITE_SPACE=" "
HASH="#"

# Prompt update function
set_prompt() {
    local emoji exit_code_symbol=""
    local last_code=$?
    
    [[ $last_code -ne 0 ]] && exit_code_symbol="‚ùå($last_code) "
    emoji="$(RANDOM_EMOJI)"
    
    PS1="$CLOCK_COLOR\t$WHITE_SPACE"
    PS1+="$BRACKET_COLOR[$JOB_COLOR\j$BRACKET_COLOR]$WHITE_SPACE"
    PS1+="$exit_code_symbol\H: $PATH_COLOR\w$RESET_COLOR$WHITE_SPACE\[$emoji\]\n"
    PS1+="$END_CHARACTER$RESET_COLOR$HASH$WHITE_SPACE"
}

# Set the prompt before each command
PROMPT_COMMAND="set_prompt")
    # Fallback if mapfile didn't work
    if [[ ${#EMOJIS[@]} -eq 0 ]]; then
        read -ra EMOJIS <<< "$(cat "${SCRIPT_DIR}/emoticons")"
    fi
else
    # Fallback emojis if file doesn't exist
    EMOJIS=("üòÄ" "üòé" "üöÄ" "‚≠ê" "üéâ" "üíª" "üî•" "‚ú®")
fi

# Debug: uncomment next line to check array size
# echo "DEBUG: Loaded ${#EMOJIS[@]} emojis" >&2

# Function to select a random emoji
RANDOM_EMOJI() {
    # Check if array has elements to prevent division by zero
    if [[ ${#EMOJIS[@]} -gt 0 ]]; then
        echo "${EMOJIS[RANDOM % ${#EMOJIS[@]}]}"
    else
        # Fallback if somehow still empty
        echo "ü§ñ"
    fi
}

# ANSI 256 color escapes (properly wrapped in \[ \] for prompt alignment)
BRACKET_COLOR="\[\033[38;5;35m\]"
CLOCK_COLOR="\[\033[38;5;35m\]"
JOB_COLOR="\[\033[38;5;33m\]"
PATH_COLOR="\[\033[38;5;33m\]"
LINE_COLOR="\[\033[38;5;248m\]"
RESET_COLOR="\[\033[0m\]"

# Line characters (UTF-8)
LINE_BOTTOM="‚îÄ"
LINE_BOTTOM_CORNER="‚îî"
LINE_UPPER_CORNER="‚îå"
LINE_STRAIGHT="‚îÄ"

# Misc symbols
END_CHARACTER="|"
WHITE_SPACE=" "
HASH="#"

# Prompt update function
set_prompt() {
    local emoji exit_code_symbol=""
    local last_code=$?
    
    [[ $last_code -ne 0 ]] && exit_code_symbol="‚ùå($last_code) "
    emoji="$(RANDOM_EMOJI)"
    
    PS1="$CLOCK_COLOR\t$WHITE_SPACE"
    PS1+="$BRACKET_COLOR[$JOB_COLOR\j$BRACKET_COLOR]$WHITE_SPACE"
    PS1+="$exit_code_symbol\H: $PATH_COLOR\w$RESET_COLOR$WHITE_SPACE\[$emoji\]\n"
    PS1+="$END_CHARACTER$RESET_COLOR$HASH$WHITE_SPACE"
}

# Set the prompt before each command
PROMPT_COMMAND="set_prompt"
